// <autogenerated>
//   This file was generated by dddappp code generator.
//   Any changes made to this file manually will be lost next time the file is regenerated.
// </autogenerated>

module aptos_demo::product {
    use std::string::{Self, String};
    use std::vector;

    use aptos_std::table::{Self, Table};
    use aptos_framework::account;
    use aptos_framework::event;

    use aptos_demo::genesis_account;

    friend aptos_demo::product_create_logic;
    friend aptos_demo::product_aggregate;

    const EID_DATA_TOO_LONG: u64 = 102;

    const PRODUCT_ID_LENGTH: u64 = 20;

    struct Events has key {
        product_id_generator_created_handle: event::EventHandle<ProductIdGeneratorCreated>,
        product_created_handle: event::EventHandle<ProductCreated>,
    }

    struct Tables has key {
        product_table: Table<String, Product>,
    }

    struct ProductIdGenerator has key {
        //id: UID,
        sequence: u128,
    }

    struct ProductIdGeneratorCreated has store, drop {
        //id: object::ID,
    }

    public(friend) fun initialize(account: &signer) acquires Events {
        genesis_account::assert_genesis_account(account);

        let res_account = genesis_account::resource_account_signer();
        move_to(&res_account, Events {
            product_id_generator_created_handle: account::new_event_handle<ProductIdGeneratorCreated>(&res_account),
            product_created_handle: account::new_event_handle<ProductCreated>(&res_account),
        });

        let product_id_generator = ProductIdGenerator {
            //id: object::new(ctx),
            sequence: 0,
        };
        move_to(&res_account, product_id_generator);

        move_to(
            &res_account,
            Tables {
                product_table: table::new(),
            },
        );
        //let product_id_generator_id = object::uid_to_inner(&product_id_generator.id);
        //transfer::share_object(product_id_generator);
        let events = borrow_global_mut<Events>(genesis_account::resouce_account_address());
        event::emit_event(&mut events.product_id_generator_created_handle, ProductIdGeneratorCreated {
            //id: product_id_generator_id
        });
    }

    struct Product has store {
        //id: UID,
        product_id: String,
        version: u64,
        name: String,
        unit_price: u128,
    }

    // public fun id(product: &Product): object::ID {
    //     object::uid_to_inner(&product.id)
    // }

    public fun product_id(product: &Product): String {
        product.product_id
    }

    public fun version(product: &Product): u64 {
        product.version
    }

    public fun name(product: &Product): String {
        product.name
    }

    public(friend) fun set_name(product: &mut Product, name: String) {
        product.name = name;
    }

    public fun unit_price(product: &Product): u128 {
        product.unit_price
    }

    public(friend) fun set_unit_price(product: &mut Product, unit_price: u128) {
        product.unit_price = unit_price;
    }

    fun new_product(
        product_id: String,
        name: String,
        unit_price: u128,
        //ctx: &mut TxContext,
    ): Product {
        assert!(std::string::length(&product_id) <= 20, EID_DATA_TOO_LONG);
        Product {
            //id: object::new(ctx),
            product_id,
            version: 0,
            name,
            unit_price,
        }
    }

    struct ProductCreated has store, drop {
        //id: option::Option<object::ID>,
        product_id: String,
        name: String,
        unit_price: u128,
    }

    // public fun product_created_id(product_created: &ProductCreated): option::Option<object::ID> {
    //     product_created.id
    // }
    //
    // public(friend) fun set_product_created_id(product_created: &mut ProductCreated, id: object::ID) {
    //     product_created.id = option::some(id);
    // }

    public fun product_created_product_id(product_created: &ProductCreated): String {
        product_created.product_id
    }

    public fun product_created_name(product_created: &ProductCreated): String {
        product_created.name
    }

    public fun product_created_unit_price(product_created: &ProductCreated): u128 {
        product_created.unit_price
    }

    public(friend) fun new_product_created(
        name: String,
        unit_price: u128,
        //product_id_generator: &mut ProductIdGenerator,
    ): ProductCreated acquires ProductIdGenerator {
        let product_id_generator = borrow_global_mut<ProductIdGenerator>(genesis_account::resouce_account_address());
        let product_id = next_product_id(product_id_generator);
        ProductCreated {
            //id: option::none(),
            product_id,
            name,
            unit_price,
        }
    }

    public(friend) fun create_product(
        name: String,
        unit_price: u128,
        //product_id_generator: &ProductIdGenerator,
        //ctx: &mut TxContext,
    ): Product acquires ProductIdGenerator {
        let product_id_generator = borrow_global<ProductIdGenerator>(genesis_account::resouce_account_address());
        let product_id = current_product_id(product_id_generator);
        let product = new_product(
            product_id,
            name,
            unit_price,
            //ctx,
        );
        product
    }

    fun current_product_id(
        product_id_generator: &ProductIdGenerator,
    ): String {
        string::utf8(u128_to_fixed_length_string(product_id_generator.sequence, PRODUCT_ID_LENGTH))
    }

    fun u128_to_fixed_length_string(n: u128, length: u64): vector<u8> {
        let s = vector::empty<u8>();
        let m = n;
        while (m > 0) {
            let digit = ((m % 10) as u8);
            vector::push_back(&mut s, digit + 48);//b'0'
            m = m / 10;
        };
        while (vector::length(&s) < length) {
            vector::push_back(&mut s, 48);//b'0'
        };
        vector::reverse(&mut s);
        s
    }

    fun next_product_id(
        product_id_generator: &mut ProductIdGenerator,
    ): String {
        product_id_generator.sequence = product_id_generator.sequence + 1;
        current_product_id(product_id_generator)
    }

    public(friend) fun save_product(product: Product) acquires Tables {
        let tables = borrow_global_mut<Tables>(genesis_account::resouce_account_address());
        table::add(&mut tables.product_table, product_id(&product), product);
    }

    public(friend) fun get_product(product_id: String): Product acquires Tables {
        let tables = borrow_global_mut<Tables>(genesis_account::resouce_account_address());
        table::remove(&mut tables.product_table, product_id)
    }

    // public fun borrow_product(product_id: String): &Product acquires Tables {
    //     let tables = borrow_global<Tables>(genesis_account::resouce_account_address());
    //     table::borrow(&tables.product_table, product_id)
    // }
    // /*
    // |         table::borrow(&tables.product_table, product_id)
    // |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // |         |
    // |         Invalid return. Resource variable 'Tables' is still being borrowed.
    // |         It is still being borrowed by this reference
    // */

    public fun get_unit_price_by_product_id(product_id: String): u128 acquires Tables {
        let tables = borrow_global<Tables>(genesis_account::resouce_account_address());
        table::borrow(&tables.product_table, product_id).unit_price
    }

    // public(friend) fun transfer_object(product: Product, recipient: address) {
    //     transfer::transfer(product, recipient);
    // }
    //
    // public(friend) fun update_version_and_transfer_object(product: Product, recipient: address) {
    //     product.version = product.version + 1;
    //     transfer::transfer(product, recipient);
    // }
    //
    // public(friend) fun share_object(product: Product) {
    //     transfer::share_object(product);
    // }
    //
    // public(friend) fun freeze_object(product: Product) {
    //     transfer::freeze_object(product);
    // }

    public(friend) fun emit_product_created(product_created: ProductCreated) acquires Events {
        let events = borrow_global_mut<Events>(genesis_account::resouce_account_address());
        event::emit_event(&mut events.product_created_handle, product_created);
    }

    // #[test_only]
    // /// Wrapper of module initializer for testing
    // public fun test_init(ctx: &mut TxContext) {
    //     init(ctx)
    // }
}
